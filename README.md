# Уважно читайте завдання, вхідні дані можуть відрізнятись!

## 1. Поясніть, яка з властивостей матриці суміжності графа вказує на те, що він містить петлі
    
    Відповідь: Головна діагональ містить ненульові елементи

## 2. Поясніть, яка з властивостей матриці суміжності графа вказує на те, що він є плотним
    
    Відповідь: Матриця містить більше ненульових елементів ніж нульових

## 3. Обчислите значення наведеної нижче суми:
   s=0
   for (i=1; i< n+1; i++)  
   s=s+i

    Відповідь: n(n +1)/2

## 4. Поясніть, яка з властивостей матриці суміжності графа вказує на те, що він містить ізольовану вершину
    
    Відповідь: Строка і стовпчик матриці містять лише нульові елементи

## 5. Припустимо, наведено список класичних (не модифікованих) алгоритмів сортування. Виберіть зі списку алгоритми сортування із середньою логарифмічною обчислювальною складністю

        Відповідь: пірамідальне сортування, сортування злиттям, швидке сортування, сортування гребінцем.

## 6. Знайдить рішенне для наступного рекурентного відношення:

   Відповідь: х(n) = х (n - 1) + 5, для n > 1, х (1)= 0


## 7. Поясніть, яка з властивостей матриці суміжності графа вказує на те, що він містить петлі

    Відповідь: Головна діагональ містить ненульові елементи


## 8. Надайте склад  порожнього стека (голова←хвост) після виконання  послідовності команд: 
   push (a), push (b), pop, push (с), push (d), pop.

    Відповідь: ca  ("a" -> "ba" -> "a" -> "ca" -> "dca" -> "ca" по такой логике можно сделать своё задание)

## 9. Які сортування (не)стабільні

    Нестабільні: QuickSort , Heap Sort, Selection sort(если нет ответов, Selection может быть стабильной) ...
    Стабільні: сортування вставкою, сортування обміном(бульбашка), сортування злиттям, сортування підрахунком.

## 10. Обчислите значення наведеної нижче суми:
    s=0
    for (i=1; i< n+1; i++) 
    for (j=1; j<n+1;j++) 
    s=s+i*j

    Відповідь: (n(n+1)/2) * (n(n+1)/2)

## 11. Поясніть, яка з властивостей матриці суміжності графа вказує на те, що він є повним

    Відповідь: Нульові елементи розташовані лише на головній діагоналі

## 12. Знайдить рішенне для наступного рекурентного відношення:
    x (n) = x (n - 1) + 5, для п > 1, х (1)= 0        Відповідь: 5*n


    x (n) = x (n-1) + n, для n > 0, х (0) = 0         Відповідь: n(n+1)/2

## 13. Матриця суміжності графа завжди буде квадратною
```Відповідь: правильно```

## 14. Матрица суміжності неорієнтованного графа завжди буде симетричною відносно головної діагоналі
```Відповідь: правильно```

## 15. Обчисліте значення наведеної нжче суми:
2^0+2^1+2^2+…2^9

```Відповідь: 1023 (бо 2^10 = 1024)```

## 16. Стійкі сортування

```
Стійкі: merge, selection, insertion, bubble...
Нестійкі: quick, heap, comb...
```

## Маємо масив у вигляді мінімальної купи, відсортуйте його за допомогою «просіювання» елементів. Наведіть відповідний псевдокод моделювання для наступного масиву А={1,4,5,9,6,10,3}

    (Есть класс MinHeap, но быть может, что это не то. MinHeap сортирует в "спадающем" режиме)


## Маємо масив чисел A={4, 1, 5, 9, 6, 10, 3}. Наведіть трасування викликів MergeSort та Merge використовуя наступний псевдокод

    MergeSort(A, p, r) 

    if p >= r return // умова виходу
    q = p + mod((r−p)/2)

    // рекурсивне  сортування отриманих масивів
    MergeSort(A, p, q)
    MergeSort(A, q + 1, r)
    Merge(A, p, q, r)


    MergeSort(A, 1, 7):
    Рекурсивний виклик MergeSort(A, 1, 4):
        Рекурсивний виклик MergeSort(A, 1, 2):
            Рекурсивний виклик MergeSort(A, 1, 1):
                Виходить з рекурсії, оскільки p>=r.
            Рекурсивний виклик MergeSort(A, 2, 2):
                Виходить з рекурсії, оскільки p>=r.
        Виклик Merge(A, 1, 1, 2), що об'єднує підмасиви {4} та {1} у {1, 4}.
    Рекурсивний виклик MergeSort(A, 3, 4):
        Рекурсивний виклик MergeSort(A, 3, 3):
            Виходить з рекурсії, оскільки p>=r.
        Рекурсивний виклик MergeSort(A, 4, 4):
            Виходить з рекурсії, оскільки p>=r.
        Виклик Merge(A, 3, 3, 4), що об'єднує підмасиви {5} та {9} у {5, 9}.
    Виклик Merge(A, 1, 2, 4), що об'єднує підмасиви {1, 4} та {5, 9} у {1, 4, 5, 9}.
    Рекурсивний виклик MergeSort(A, 5, 7):
        Рекурсивний виклик MergeSort(A, 5, 5):
            Виходить з рекурсії, оскільки p>=r.
        Рекурсивний виклик MergeSort(A, 6, 7):
            Рекурсивний виклик MergeSort(A, 6, 6):
                Виходить з рекурсії, оскільки p>=r.
            Рекурсивний виклик MergeSort(A, 7, 7):
                Виходить з рекурсії, оскільки p>=r.
            Виклик Merge(A, 6, 6, 7), що об'єднує підмасиви {10} та {3} у {3, 10}.
        Виклик Merge(A, 5, 6, 7), що об'єднує підмасиви {6} та {3, 10} у {3, 6, 10}.
    Виклик Merge(A, 1, 4, 7), що об'єднує підмасиви {1, 4, 5, 9} та {3, 6, 10} у відсортований масив {1, 3, 4, 5, 6, 9, 10}



## Переведення двійкового числа у вісімкову систему без переведення в десяткову та прописати моделювання.

    Використаємо тріади.

    Представимо бінарне число як рядок

    Добавимо нулі для вирівнювання
    
    while length(binNum) % 3 != 0:
        binNum = "0" + binNum

    Створимо змінну-результат
    String octalNum

    for i from 0 to length(binNum) i + 3:
        octalNum += switchOctal(subString(i, i + 3))
    
    function switchOctal(num):
        return swich (num):
            case "000" -> "0";
            case "001" -> "1";
            case "010" -> "2";
            case "011" -> "3";
            case "100" -> "4";
            case "101" -> "5";
            case "110" -> "6";
            case "111" -> "7";
            default -> "";


    (Псевдо код сделан на основе кода. Если есть время, лучше переделать под себя)
    (Моделирование в классе binToOct. Попытайтесь +- переделать под себя)

    

## Наведіть приклад псевдокоду алгоритму  сортування бульбашкою.

    function bubbleSort(a):
        for i = 0 to n - 1
            for j = 0 to n - i - 1
                if a[j] > a[j + 1] -> swap(a[j], a[j + 1])



## Маємо два відсортированних масива, виконайте їхне злиття в відсортированний масив. Наведіть відповідний псевдокод та виконайте його моделювання для наступних двох масивів A= {1,4,5,9} B={3,6,10}

        i = 0; j = 0; k = 0
        while i < sizeL and j < sizeR:
            if L[i] <= R[j]:
                arr[k] = L[i]
                i = i + 1
            else:
                arr[k] = R[j]
                j = j + 1
            k = k + 1

            while i < sizeL:
                arr[k] = L[i]
                i = i + 1
                k = k + 1

            while j < sizeR:
                arr[k] = R[j]
                j = j + 1
                k = k + 1

    (Моделирование в классе Merge)


## Алгоритм для знаходження максимальної різниці між елементами масиву:

    max = arr[0]
    min = arr[0]
    for i from 0 to arrSize

        if (arr[i] < min) -> min = arr[i]
        if (arr[i] > max) -> max = arr[i]

    Результат: max - min

    (Моделювання в класі Diff)


## Алгоритм для знаходження мінімальної різниці між елементами масиву:

    min_diff = abs(arr[0] - arr[1])
    
    for i from 0 to arrSize
        for j from i + 1 to arrSize
            if (abs(arr[i] - arr[j]) < min_diff) min_diff = abs(arr[i] - arr[j])

    Результат: min_diff

    (Моделирование в классе Diff)

## Бульбашкове сортування (сортвування обміном)
Псевдокод
```
for i from 0 to n(size) - 1
   for j from 0 to n(size) - 1 - i
      if (arr[j] > arr[j + 1])
         swap(arr[j], arr[j + 1])
         
(Моделировние в классе Bubble)
```

## Напишіть псевдокод алгоритму обміну місцями мінімального та максимального елементів масиву А.
Псевдокод
```
min = 0;
max = 0;

for i from 1 to arraySize
   if (arr[i] > arr[max]) -> max = i
   if (arr[i] < arr[min]) -> min = i
   
temp = arr[min];
arr[min] = arr[max];
arr[max] = arr[min];

(Моделирование в классе minMaxSwap)
```

## Наведіть приклад псевдокоду алгоритму "дурного" сортування.

```
(stupid sort)

StupidSort(arr)
   while not sorted:
      arr random permutation
      

(По презентации 3.1)
public static void sort(int[] arr) {
        int n = arr.length;
        boolean swapped;
        
        do {
            swapped = false;
            
            for (int i = 0; i < n - 1; i++) {
                for (int j = 0; j < n - 1; j++) {
                    if (arr[j] > arr[j + 1]) {
                        int temp = arr[j];
                        arr[j] = arr[j + 1];
                        arr[j + 1] = temp;
                        swapped = true;
                    }
                }
            }
            
        } while (swapped);
    }
```

## Алгоритм Euclid (m, n) для обчислення значення функції gcd (m, n)
Псевдокод
``` 
function gcd(m, n):
    while n != 0:
        r = m mod n
        m = n
        n = r
    return m

(Моделирование в классу EuclidGCD)
```